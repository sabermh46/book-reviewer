<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Book Library</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="app">
        <header id="navbar">

        </header>
        <main id="content"></main>
    </div>

    <div id="book-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn">
                <img src="assets/close.svg" alt="">
            </span>
            <div id="book-detail-content"></div>
        </div>
    </div>

    <script>
      
        class Router {
    constructor(routesConfig) {
        this.routes = new Map(); // Use a Map to store routes, allows for more complex keys/values
        this.currentView = null;
        this.previousHash = ''; // Stores the hash that the app navigated *from*
        this.hashBeforeModal = ''; // Stores the hash *before* opening a modal
        this.modalOpenHash = ''; // Stores the hash of the currently open modal

        this.parseRoutesConfig(routesConfig); // Process the config into a Map
        this.init();
    }

    // Parses the routes configuration into a Map with regex and parameter names
    parseRoutesConfig(config) {
        for (const path in config) {
            if (config.hasOwnProperty(path)) {
                // Escape special regex characters except for the parameter syntax
                let regexPath = path.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
                                  .replace(/:(\w+)/g, '([^/]+)'); // Convert :param to regex group

                // Ensure the regex correctly matches the full hash, with optional trailing slash
                if (regexPath.endsWith('/')) {
                    regexPath = regexPath.slice(0, -1) + '(/)?$'; // Match with or without trailing slash
                } else {
                    regexPath += '(/)?$'; // Add optional trailing slash if not already there
                }
                const regex = new RegExp(`^${regexPath}`);

                // Extract parameter names from the original path string
                const paramNames = (path.match(/:(\w+)/g) || []).map(p => p.substring(1));

                this.routes.set(regex, { handler: config[path], paramNames: paramNames });
            }
        }
    }

    init() {
        // Add event listener for hash changes
        window.addEventListener('hashchange', () => this.handleRoute());
        // Handle the initial route when the page loads
        this.handleRoute();
    }

    async handleRoute() {
        const hash = window.location.hash || '#/home';

        // --- Step 1: Handle Modal State Transitions ---

        // If navigating to a book modal
        if (hash.startsWith('#/book/')) {
            // If no modal was previously marked as open, record the current 'previousHash'
            if (!this.modalOpenHash) {
                this.hashBeforeModal = this.previousHash || '#/home'; // Fallback to home if no actual previous hash
            }
            this.modalOpenHash = hash; // Mark the current book hash as the open modal
        }
        // If navigating away from a book modal (to a non-modal hash)
        else {
            if (this.modalOpenHash) { // Check if a modal was actually open
                this.closeBookModal(); // Close the modal overlay
                this.modalOpenHash = ''; // Reset modal state

                // If the new hash is the same as the one we returned from
                // and it's not a book modal, prevent re-rendering the underlying view.
                if (hash === this.hashBeforeModal) {
                    this.previousHash = hash; // Ensure previousHash is correctly set for future navigations
                    return; // Prevent further processing if just closing modal to same page
                }
            }
            // If not navigating to or from a book modal, destroy the previous full view
            if (this.currentView?.destroy) {
                this.currentView.destroy();
            }
        }

        // --- Step 2: Prevent Duplicate Routing for regular pages ---
        // This check needs to be AFTER modal state handling,
        // as modal closing might set the hash back to a previous one.
        if (hash === this.previousHash) {
            // If the hash is genuinely unchanged and no modal transition is involved,
            // then there's nothing new to do.
            return;
        }

        // Always update previousHash to the *current* hash for the next navigation
        // This is the hash the user is currently on, before any *next* navigation occurs.
        this.previousHash = hash;

        // --- Step 3: Match and Execute Route Handler ---

        let matchedRouteHandler = null;
        let pathParams = {};

        // Iterate through registered routes to find a match using regex
        for (const [regex, routeConfig] of this.routes) {
            const match = hash.match(regex);
            if (match) {
                matchedRouteHandler = routeConfig.handler;
                // Extract parameters from the regex match
                routeConfig.paramNames.forEach((name, index) => {
                    pathParams[name] = match[index + 1]; // match[0] is the full match, params start from match[1]
                });
                break; // Found a match, stop searching
            }
        }

        if (matchedRouteHandler) {
            // Execute the route handler, passing extracted parameters
            // The handler itself decides what to do (e.g., render a view, open a modal)
            this.currentView = await matchedRouteHandler(pathParams); // Handler can return a view instance
            if (this.currentView && typeof this.currentView.render === 'function' && !hash.startsWith('#/book/')) {
                 // Only render if it's a full page view (not a modal that overlays)
                this.currentView.render();
            }
        } else {
            // No route matched, handle as a 404 or redirect to home
            console.warn(`No route found for: ${hash}. Redirecting to home.`);
            window.location.hash = '#/home';
        }
    }

    // Displays the book details modal
    async showBookModal(bookId) {
        const modal = document.getElementById('book-modal');
        const content = document.getElementById('book-detail-content');

        // Show loading state and make modal visible
        modal?.classList.add('show');
        content.innerHTML = '<div class="loading">Loading book details...</div>';

        try {
            // Fetch book details from the API
            const response = await fetch(`https://gutendex.com/books/${bookId}`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const book = await response.json();

            // Render book details into the modal
            content.innerHTML = `
                <div class="book-detail">
                    <div class="book-detail-cover">
                        <img src="${book.formats['image/jpeg'] || 'no-cover.jpg'}" alt="${book.title}">
                        <button class="wishlist-btn ${WishlistManager.isWishlisted(book.id) ? 'red' : ''}">
                            ‚ù§
                        </button>
                    </div>
                    <div class="book-detail-info">
                        <h2>${book.title}</h2>
                        <div class="book-meta">
                            <p><strong>Author:</strong> ${book.authors.map(a => a.name).join(', ') || 'N/A'}</p>
                            <p><strong>Subjects:</strong> ${book.subjects?.slice(0, 3).join(', ') || 'N/A'}</p>
                        </div>
                    </div>
                </div>
            `;

            // Setup wishlist button functionality
            const wishlistBtn = content?.querySelector('.wishlist-btn');
            if (wishlistBtn) {
                // In Router's showBookModal:
                wishlistBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent triggering the card click
                    const isWishlisted = WishlistManager.toggleWishlist(book.id);
                    wishlistBtn.classList.toggle('red', isWishlisted);
                });
            }

        } catch (error) {
            console.error("Error fetching book details:", error);
            content.innerHTML = `<div class="error">Error loading book details. Please try again.</div>`;
        }

        // Setup close handlers for the modal (using onclick to overwrite any previous listeners)
        document.querySelector('.close-btn')?.addEventListener('click', () => {
            console.log("Closing book modal, returning to:", this.hashBeforeModal);
            window.location.hash = this.hashBeforeModal; // Navigate back to the hash before the modal
        }, { once: true }); // Use { once: true } for cleaner listener removal

        modal?.addEventListener('click', (e) => {
            if (e.target === modal) {
                console.log("Closing book modal (clicked outside), returning to:", this.hashBeforeModal);
                window.location.hash = this.hashBeforeModal; // Navigate back to the hash before the modal
            }
        }, { once: true }); // Use { once: true } for cleaner listener removal
    }

    // Hides and clears the book details modal
    closeBookModal() {
        const modal = document.getElementById('book-modal');
        modal?.classList.remove('show');
        document.getElementById('book-detail-content').innerHTML = ''; // Clear content
        // If you had complex event listeners attached *inside* showBookModal without { once: true },
        // you would need to explicitly remove them here. Using `onclick` or `{ once: true }`
        // on the close elements simplifies this.
    }
}
        // ========== WISHLIST MANAGER (NEW) ==========
        class WishlistManager {
            static getWishlist() {
                return JSON.parse(localStorage.getItem('wishlist')) || [];
            }

            static isWishlisted(bookId) {
                const wishlist = WishlistManager.getWishlist();
                return wishlist.includes(parseInt(bookId)); // Ensure bookId is integer for comparison
            }

            static toggleWishlist(bookId) {
                const wishlist = WishlistManager.getWishlist();
                const idNum = parseInt(bookId);
                const index = wishlist.indexOf(idNum);
                let isWishlisted;

                if (index === -1) {
                    wishlist.push(idNum);
                    isWishlisted = true;
                } else {
                    wishlist.splice(index, 1);
                    isWishlisted = false;
                }

                    localStorage.setItem('wishlist', JSON.stringify(wishlist));
                    document.dispatchEvent(new CustomEvent('wishlistUpdated'));
                    return isWishlisted; // Return the new state
                }
            static getWishlistCount() {
                return WishlistManager.getWishlist().length;
            }
        }

        // ========== VIEWS ==========
        class HomeView {
            constructor(routerInstance) { // Accept router instance
                this.router = routerInstance; // Store it
                this.currentPage = 1;
                this.searchTerm = '';
                this.filterTopic = '';
                this.books = [];
            }

            async render() {
                const content = document.getElementById('content');
                content.innerHTML = `
                    <div class="controls">
                        <div class="search-box">
                            <input type="text" placeholder="Search books..." value="${this.searchTerm}">
                            <button class="clear-search">&times;</button>
                        </div>
                        <select class="topic-filter">
                            <option value="">All Topics</option>
                        </select>
                    </div>
                    <div class="books-grid"></div>
                    <div class="pagination"></div>
                `;

                await this.loadBooks();
                this.setupEventListeners();
            }

            // Optional: A destroy method to clean up event listeners if necessary
            destroy() {
                // Remove listeners if they are not cleaned up by innerHTML replacement
                // For this structure, innerHTML usually handles it implicitly
            }

            async loadBooks() {
                const content = document.getElementById('content');
                const booksGrid = content.querySelector('.books-grid');
                if (booksGrid) {
                    booksGrid.innerHTML = '<div class="loading">Loading books...</div>';
                }


                let url = `https://gutendex.com/books/?page=${this.currentPage}`;
                if (this.searchTerm) url += `&search=${encodeURIComponent(this.searchTerm)}`;
                if (this.filterTopic) url += `&topic=${encodeURIComponent(this.filterTopic)}`;

                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    this.books = data.results;
                    this.renderBooks(data.count);
                    this.populateTopics();
                } catch (error) {
                    console.error("Error loading books:", error);
                    if (booksGrid) {
                        booksGrid.innerHTML = '<div class="error">Error loading books. Please try again.</div>';
                    }
                }
            }

            renderBooks(totalCount) {
                const grid = document.querySelector('.books-grid');
                if (!grid) return; // Ensure grid exists before trying to render into it
                const pagination = document.querySelector('.pagination');

                if (this.books.length === 0) {
                    grid.classList.add('no-results');
                    pagination.innerHTML = ``
                    grid.innerHTML = `
                        <div class="no-results">
                            <div class="no-results-icon">üîç</div>
                            <h3>No books found</h3>
                            <p>Try adjusting your search or filter criteria</p>
                            <button class="clear-filters">Clear all filters</button>
                        </div>
                    `;
        
        // Add event listener for clear filters button
            grid.querySelector('.clear-filters')?.addEventListener('click', () => {
                this.searchTerm = '';
                this.filterTopic = '';
                this.currentPage = 1;
                
                // Clear UI elements
                const searchInput = document.querySelector('.search-box input');
                if (searchInput) searchInput.value = '';
                
                const topicFilter = document.querySelector('.topic-filter');
                if (topicFilter) topicFilter.value = '';
                
                this.loadBooks();
            });
            return;
        }
                grid.classList.remove('no-results');
                grid.innerHTML = this.books.map(book => `
                    <div class="book-card" data-id="${book.id}">
                        <div class="book-cover">
                            <img src="${book.formats['image/jpeg'] || 'no-cover.jpg'}" alt="${book.title}">
                            <button class="wishlist-btn ${WishlistManager.isWishlisted(book.id) ? 'red' : ''}">‚ù§</button>
                        </div>
                        <div class="book-info">
                            <h3>${book.title}</h3>
                            <p>${book.authors.map(a => a.name).join(', ') || 'N/A'}</p>
                        </div>
                    </div>
                `).join('');

                this.setupPagination(totalCount);
            }

            setupPagination(totalCount) {
                const totalPages = Math.ceil(totalCount / 32);
                const pagination = document.querySelector('.pagination');

                if (!pagination || totalPages <= 1) {
                    if (pagination) pagination.innerHTML = '';
                    return;
                }

                // Logic to show a limited number of page buttons around the current page
                let startPage = Math.max(1, this.currentPage - 2);
                let endPage = Math.min(totalPages, this.currentPage + 2);

                if (endPage - startPage < 4) { // Ensure at least 5 buttons if possible
                    if (startPage === 1) endPage = Math.min(totalPages, startPage + 4);
                    else if (endPage === totalPages) startPage = Math.max(1, endPage - 4);
                }


                let pageButtonsHtml = '';
                for (let i = startPage; i <= endPage; i++) {
                    pageButtonsHtml += `<button class="page-btn ${i === this.currentPage ? 'active' : ''}">${i}</button>`;
                }


                pagination.innerHTML = `
                    <button class="prev-btn" ${this.currentPage === 1 ? 'disabled' : ''}>Previous</button>
                    ${pageButtonsHtml}
                    <button class="next-btn" ${this.currentPage === totalPages ? 'disabled' : ''}>Next</button>
                `;

                // Re-attaching listeners (ensure they are not duplicated if render is called multiple times)
                // A better approach for persistent listeners is event delegation on the parent
                pagination.querySelector('.prev-btn')?.addEventListener('click', () => {
                    this.currentPage--;
                    this.loadBooks();
                });

                pagination.querySelector('.next-btn')?.addEventListener('click', () => {
                    this.currentPage++;
                    this.loadBooks();
                });

                pagination.querySelectorAll('.page-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.currentPage = parseInt(btn.textContent);
                        this.loadBooks();
                    });
                });
            }

            populateTopics() {
                // Fetch all topics from a common source if available, or populate based on current books
                // For now, populate based on current books which is limited
                const topics = new Set();
                this.books.forEach(book => {
                    book.subjects?.forEach(subject => {
                        // Extracting the main part of the subject string
                        const mainTopic = subject.split(' -- ')[0].split('(')[0].trim();
                        if (mainTopic) topics.add(mainTopic);
                    });
                });

                const select = document.querySelector('.topic-filter');
                if (!select) return;

                // Clear previous options except "All Topics"
                select.querySelectorAll('option:not([value=""])').forEach(option => option.remove());

                const sortedTopics = Array.from(topics).sort(); // Sort topics alphabetically

                sortedTopics.forEach(topic => {
                    const option = document.createElement('option');
                    option.value = topic;
                    option.textContent = topic;
                    option.selected = this.filterTopic === topic;
                    select.appendChild(option);
                });
            }

            setupEventListeners() {
                const content = document.getElementById('content'); // Delegate events to content

                // Search with debounce
                let searchTimeout;
                content.querySelector('.search-box input')?.addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        this.searchTerm = e.target.value.trim();
                        this.currentPage = 1;
                        this.loadBooks();
                    }, 500);
                });

                // Clear search
                content.querySelector('.clear-search')?.addEventListener('click', () => {
                    const searchInput = content.querySelector('.search-box input');
                    if (searchInput) searchInput.value = '';
                    this.searchTerm = '';
                    this.currentPage = 1;
                    this.loadBooks();
                });

                // Topic filter
                content.querySelector('.topic-filter')?.addEventListener('change', (e) => {
                    this.filterTopic = e.target.value;
                    this.currentPage = 1;
                    this.loadBooks();
                });

                // Book card clicks (event delegation)
                content.querySelector('.books-grid')?.addEventListener('click', (e) => {
                    const card = e.target.closest('.book-card');
                    if (card) {
                        const bookId = card.dataset.id;
                        const wishlistBtn = e.target.closest('.wishlist-btn');
                        if (wishlistBtn) {
                            e.preventDefault();
                            e.stopPropagation(); // Prevent event bubbling
                            
                            const isWishlisted = WishlistManager.toggleWishlist(bookId);
                            wishlistBtn.classList.toggle('red', isWishlisted);
                        } else {
                            window.location.hash = `#/book/${bookId}`;
                        }
                    }
                });
            }
        }

        class WishlistView {
            constructor(routerInstance) {
                this.router = routerInstance;
                this.renderBind = this.render.bind(this); // Bind render for event listener
            }

            async render() {
                const content = document.getElementById('content');
                const wishlist = WishlistManager.getWishlist();

                if (wishlist.length === 0) {
                    content.innerHTML = `
                        <div class="empty-wishlist">
                            <div class="empty-icon">‚ù§Ô∏è</div>
                            <h3>Your wishlist is empty</h3>
                            <p>Save books you're interested in by clicking the heart icon</p>
                            <a href="#/home" class="browse-books">Browse books</a>
                        </div>
                    `;
                    return;
                }

                content.innerHTML = '<div class="loading">Loading wishlist...</div>';

                try {
                    const books = await Promise.all(
                        wishlist.map(id => fetch(`https://gutendex.com/books/${id}`).then(r => {
                            if (!r.ok) throw new Error(`HTTP error! status: ${r.status}`);
                            return r.json();
                        }))
                    );

                    content.innerHTML = `
                        <h2>Your Wishlist</h2>
                        <div class="books-grid">
                            ${books.map(book => `
                                <div class="book-card" data-id="${book.id}">
                                    <div class="book-cover">
                                        <img src="${book.formats['image/jpeg'] || 'no-cover.jpg'}" alt="${book.title}">
                                        <button class="wishlist-btn red">‚ù§</button>
                                    </div>
                                    <div class="book-info">
                                        <h3>${book.title}</h3>
                                        <p>${book.authors.map(a => a.name).join(', ') || 'N/A'}</p>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    `;

                    // Setup card clicks (event delegation)
                    document.querySelector('.books-grid')?.addEventListener('click', (e) => {
                        const card = e.target.closest('.book-card');
                        if (card) {
                            const bookId = card.dataset.id;
                            const wishlistBtn = e.target.closest('.wishlist-btn');
                            if (wishlistBtn) {
                                e.preventDefault();
                                WishlistManager.toggleWishlist(bookId);
                                card.remove(); // Immediately remove from display
                                // No need to call router.updateWishlistCount() here
                            } else {
                                window.location.hash = `#/book/${bookId}`;
                            }
                        }
                    });

                } catch (error) {
                    console.error("Error loading wishlist:", error);
                    content.innerHTML = '<div class="error">Error loading wishlist. Please try again.</div>';
                }
            }

            // Listen for wishlist updates to re-render if needed (e.g., if a book is un-wishlisted from the modal)
            setupEventListeners() {
                document.addEventListener('wishlistUpdated', this.renderBind);
            }

            destroy() {
                // Clean up event listeners to prevent memory leaks
                document.removeEventListener('wishlistUpdated', this.renderBind);
            }
        }

        // ========== NAVBAR ==========
        class Navbar {
            constructor() {
                this.navbarElement = document.createElement('nav');
                this.renderBind = this.render.bind(this); // Bind render for event listener
            }

            render() {
                const wishlistCount = WishlistManager.getWishlistCount();

                this.navbarElement.innerHTML = `
                    <div class='brand'>
                        Gutendex Books
                    </div>
                    <div class="nav-links">
                        <a href="#/home">Home</a>
                        <a href="#/wishlist">Wishlist <span class="wishlist-count">${wishlistCount > 0 ? `(${wishlistCount})` : ''}</span></a>
                    </div>
                `;
                return this.navbarElement;
            }

            // Listen for wishlist updates to re-render its count
            setupEventListeners() {
                document.addEventListener('wishlistUpdated', this.renderBind);
            }

            // Optional: Destroy method if listeners need cleaning up
            destroy() {
                 document.removeEventListener('wishlistUpdated', this.renderBind);
            }
        }

        // ========== INITIALIZATION ==========
        document.addEventListener('DOMContentLoaded', () => {
            // Setup Navbar
            const navbar = new Navbar();
            document.getElementById('navbar').appendChild(navbar.render());
            navbar.setupEventListeners(); // Listen for wishlist updates

            let router;
            router = new Router({
                '#/home': () => new HomeView(router), // Pass router instance
                '#/book/:id': (params) => router.showBookModal(params.id),
                '#/wishlist': () => new WishlistView(router) // Pass router instance
            });

            // Set default route
            if (!window.location.hash) {
                window.location.hash = '#/home';
            }
        });
    </script>
</body>
</html>